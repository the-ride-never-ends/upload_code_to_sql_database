import json
from typing import Any


from code_entry.create_code_entry import CodeEntry


def upload_code_entry(db_connection: Any, code_entry: CodeEntry) -> None:
    """
    Upload or update a code entry in the database using an atomic transaction.

    Upserts a code entry into both the codes and metadata tables within a
    single database transaction. This ensures atomicity - either both tables
    are updated successfully or neither is modified. The function handles
    both new entries and updates to existing entries with proper versioning.

    The function implements a versioning system where:
    - Each unique public interface gets an immutable CID in the metadata table
    - Code implementations are versioned in the codes table with version_cid
    - Updates to existing interfaces create new versions while preserving history

    Args:
        db_connection: Active MySQL database connection with transaction
            support (autocommit=False). Must have INSERT/UPDATE privileges on
            both codes and metadata tables.

        code_entry: CodeEntry object containing all data for insertion:
            - cid: Unique Content identifier for this version of the code
            - signature: Function/class signature
            - docstring: Documentation string
            - computer_code: Complete source code
            - metadata: Dictionary with required fields:
                - cid: Unique Public interface identifier (immutable)
                - code_name, code_type, is_test, file_path, tags

    Transaction Flow:
        1. Start transaction (implicit with first query)
        2. Check if metadata.cid already exists to get immutable code_cid
        3. REPLACE INTO codes table:
           - immutable_cid (primary key, from existing or new)
           - version_cid (current version identifier)
           - signature, docstring, computer_code
        4. INSERT ... ON DUPLICATE KEY UPDATE into metadata table:
           - Updates existing metadata or creates new entry
           - Uses immutable code_cid as foreign key
           - Tags serialized as JSON
        5. COMMIT if both succeed
        6. ROLLBACK if any failure occurs

    Raises:
        Exception: For any database errors (connection loss, timeout,
            constraint violations, etc.). Transaction is rolled back.
            Original error is re-raised with context.

    Data Handling:
        - All string values use parameterized queries for SQL safety
        - Tags list is serialized to JSON string for storage
        - Long text fields (code, docstring) handled as TEXT type
        - Timestamps are auto-generated by database
        - version_cid initialized to match cid for first version
        - REPLACE INTO allows updating existing code versions
        - ON DUPLICATE KEY UPDATE handles metadata changes
        - Immutable CID system maintains interface consistency

    Example:
        code_entry = CodeEntry(
            cid="QmX7G8DPK...",  # Version-specific CID
            signature="def calculate(x: int) -> int:",
            docstring="Calculate result.",
            computer_code="def calculate(x: int) -> int:\n    ...",
            metadata={
                'cid': 'QmABC123...',  # Immutable interface CID
                'code_name': 'calculate',
                'code_type': 'function',
                'is_test': False,
                'file_path': 'utils/math.py',
                'tags': ['utils', 'math']
            }
        )

        try:
            upload_code_entry(db_connection, code_entry)
            print("Upload/update successful")
        except Exception as e:
            print(f"Upload failed: {e}")

    Resource Management:
        - Creates and manages cursors internally
        - All cursors closed even on error
        - Transaction always resolved (commit or rollback)
        - No partial state possible in database

    Notes:
        - Function has no return value; success is implicit
        - Supports both new entries and updates to existing code
        - Maintains version history through immutable CID system
        - Safe for concurrent use with proper isolation
        - Tags serialization uses standard JSON format
    """
    cursor = None
    try:
        # Create cursor for transaction
        cursor = db_connection.cursor()

        # Find if this public interface already exists
        existing_cid_sql = "SELECT code_cid FROM metadata WHERE cid = %s"
        cursor.execute(existing_cid_sql, (code_entry.metadata["cid"],))
        result = cursor.fetchone()
        immutable_cid = result[0] if result else code_entry.cid

        # SQL for inserting into codes table
        codes_sql = """
        REPLACE INTO codes (cid, version_cid, signature, docstring, computer_code)
        VALUES (%s, %s, %s, %s, %s)
        """

        # Parameters for codes table (version_cid initially same as cid)
        codes_params = (
            immutable_cid,
            code_entry.cid,  # version_cid initially same as cid, but changes if the code already exists.
            code_entry.signature,
            code_entry.docstring,
            code_entry.computer_code,
        )

        # Execute first INSERT (codes table)
        cursor.execute(codes_sql, codes_params)

        # SQL for inserting into metadata table
        metadata_sql = """
        INSERT INTO metadata (cid, code_cid, code_name, code_type, is_test, file_path, tags)
        VALUES (%s, %s, %s, %s, %s, %s, %s)
        ON DUPLICATE KEY UPDATE
            code_name = VALUES(code_name),
            code_type = VALUES(code_type),
            is_test = VALUES(is_test),
            file_path = VALUES(file_path),
            tags = VALUES(tags)
        """

        # Serialize tags to JSON
        tags_json = json.dumps(code_entry.metadata["tags"])

        # Parameters for metadata table
        metadata_params = (
            code_entry.metadata["cid"],
            immutable_cid,  # code_cid (foreign key reference)
            code_entry.metadata["code_name"],
            code_entry.metadata["code_type"],
            code_entry.metadata["is_test"],
            code_entry.metadata["file_path"],
            tags_json,
        )

        # Execute second INSERT (metadata table)
        cursor.execute(metadata_sql, metadata_params)

        # If we reach here, both operations succeeded - commit transaction
        db_connection.commit()

    except Exception as e:
        # Any error - rollback transaction to maintain atomicity
        db_connection.rollback()
        # Re-raise the original exception
        raise e

    finally:
        # Always clean up cursor, even if close() fails
        if cursor is not None:
            try:
                cursor.close()
            except Exception:
                # If cursor.close() fails, we still want to raise the original error
                # Don't let cursor cleanup errors mask the real problem
                pass
